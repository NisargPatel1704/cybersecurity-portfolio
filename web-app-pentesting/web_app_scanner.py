import argparse
import requests
import json
from datetime import datetime
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
from tqdm import tqdm

class WebAppScanner:
    """
    A modular scanner for detecting common web application vulnerabilities.
    """
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.session = requests.Session()
        self.findings = []

    def _load_payloads(self, payload_file: str) -> list:
        """Loads payloads from a specified file."""
        try:
            with open(payload_file, 'r', encoding='utf-8') as f:
                return [line.strip() for line in f if line.strip()]
        except FileNotFoundError:
            print(f"[!] Payload file not found: {payload_file}")
            return []

    def test_sql_injection(self, payload_file: str = "payloads/sqli.txt"):
        """Tests for SQL injection vulnerabilities."""
        print(f"\n[+] Starting SQL Injection scan on {self.base_url}")
        sqli_payloads = self._load_payloads(payload_file)
        if not sqli_payloads:
            return
            
        parsed_url = urlparse(self.base_url)
        query_params = parse_qs(parsed_url.query)

        for param in query_params:
            original_value = query_params[param][0]
            for payload in tqdm(sqli_payloads, desc=f"Testing param '{param}' for SQLi"):
                query_params[param] = original_value + payload
                new_query = urlencode(query_params, doseq=True)
                test_url = urlunparse(parsed_url._replace(query=new_query))
                
                try:
                    res = self.session.get(test_url, timeout=5)
                    # A simple but common check for SQL errors
                    if any(error in res.text.lower() for error in ["sql syntax", "mysql", "you have an error"]):
                        finding = {
                            "vulnerability": "SQL Injection",
                            "url": test_url,
                            "parameter": param,
                            "payload": payload,
                            "evidence": "SQL error message detected in response."
                        }
                        self.findings.append(finding)
                        print(f"  [!] Possible SQLi found at parameter '{param}' with payload: {payload}")
                        break # Move to next parameter once a vulnerability is found
                except requests.RequestException:
                    continue
            query_params[param] = original_value # Reset parameter for next test

    def test_xss(self, payload_file: str = "payloads/xss.txt"):
        """Tests for reflected XSS vulnerabilities."""
        print(f"\n[+] Starting Reflected XSS scan on {self.base_url}")
        xss_payloads = self._load_payloads(payload_file)
        if not xss_payloads:
            return

        parsed_url = urlparse(self.base_url)
        query_params = parse_qs(parsed_url.query)
        
        for param in query_params:
            original_value = query_params[param][0]
            for payload in tqdm(xss_payloads, desc=f"Testing param '{param}' for XSS"):
                query_params[param] = payload
                new_query = urlencode(query_params, doseq=True)
                test_url = urlunparse(parsed_url._replace(query=new_query))
                
                try:
                    res = self.session.get(test_url, timeout=5)
                    if payload in res.text:
                        finding = {
                            "vulnerability": "Reflected XSS",
                            "url": test_url,
                            "parameter": param,
                            "payload": payload,
                            "evidence": "Payload was reflected in the HTML response."
                        }
                        self.findings.append(finding)
                        print(f"  [!] Possible Reflected XSS found at parameter '{param}' with payload: {payload}")
                        break
                except requests.RequestException:
                    continue
            query_params[param] = original_value

    def generate_report(self, output_file: str):
        """Saves the findings to a JSON report."""
        if not self.findings:
            print("\n[+] No vulnerabilities found.")
            return

        report = {
            "target": self.base_url,
            "scan_date": datetime.now().isoformat(),
            "findings": self.findings
        }
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=4)
        print(f"\n[+] Scan complete. Report saved to {output_file}")


def main():
    parser = argparse.ArgumentParser(description="Web Application Vulnerability Scanner")
    parser.add_argument("-u", "--url", required=True, help="Target URL with query parameters (e.g., 'http://test.com/search.php?q=test')")
    parser.add_argument("-s", "--scan", required=True, choices=['sqli', 'xss', 'all'], help="Type of scan to perform")
    parser.add_argument("--sqli-payloads", default="payloads/sqli.txt", help="Path to SQL injection payloads file")
    parser.add_argument("--xss-payloads", default="payloads/xss.txt", help="Path to XSS payloads file")
    parser.add_argument("-o", "--output", default="web_app_report.json", help="Output file for the JSON report")
    
    args = parser.parse_args()
    
    scanner = WebAppScanner(args.url)
    
    if args.scan in ['sqli', 'all']:
        scanner.test_sql_injection(args.sqli_payloads)
    
    if args.scan in ['xss', 'all']:
        scanner.test_xss(args.xss_payloads)
        
    scanner.generate_report(args.output)


if __name__ == "__main__":
    main()